## 1. 堆栈

栈是一种后入先出的结构，计算机中也有一块满足该特性的动态内存区域，程序可以将数据压入栈中或者将数据从栈中弹出，从而使栈动态的增大或减小。

除此之外，堆也是计算机中的一中内存区域。堆与栈的区别如下

> 1. 栈一般由操作系统来分配和释放，堆由程序员通过编程语言来申请创建与释放。
> 2. 栈用来存放函数的参数、返回值、局部变量、函数调用时的临时上下文等，堆用来存放全局变量。我们可以这样理解数据存放的规则：只要是局部的、占用空间确定的数据，一般都存放在stack 里面，否则就放在 heap 里面。
> 3. 栈的访问速度相对比堆快。
> 4. 一般来说，每个线程分配一个stack，每个进程分配一个heap，也就是说，stack 是线程独占的，heap 是线程共用的。
> 5. stack 创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow 错误，而heap的大小是不确定的，需要的话可以不断增加。
> 6. 栈是由高地址向低地址增长的，而堆是由低地址向高地址增长的。

在 C/C++ 中，程序员申请的内存空间使用完毕后需要自己释放，在 Java、Go 等语言中，提供了一种主动释放申请的内存空间的功能，这就是垃圾回收机制。



## 2. Go的堆栈

Go 是自己管理内存的，而不是交给操作系统，它每次从操作系统申请一大块内存，然后按照 Google 的 `TCMalloc` 算法进行内存分配，也划分为堆、栈等很多区域。

官方对堆栈的解释：

> 只要有对变量的引用，变量就会存在，而它存储的位置与语言的语义无关。如果可能，变量会被分配到其函数的栈，但如果编译器无法证明函数返回之后变量是否仍然被引用，就必须在堆上分配该变量，采用垃圾回收机制进行管理，从而避免指针悬空。此外，局部变量如果非常大，也会存在堆上。
>
> 在编译器中，如果变量具有地址，就作为堆分配的候选，但如果逃逸分析可以确定其生存周期不会超过函数返回，就会分配在栈上。
>
> 总之，分配在堆还是栈完全由编译器确定。



 Go 里变量分配在由编译器决定，我们虽然无法通过变量的类型判断它的存储位置，但可以通过打印程序的汇编代码来查看，主要使用 `go tool compile` 命令。

```go
// eg
package main

import "fmt"

func main() {
	var a [1]int
	c := a[:]
	fmt.Println(c)
}
```

```bash
$ go tool compile -S main.go

$ go tool compile -m main.go
main.go:8:13: inlining call to fmt.Println
main.go:6:6: moved to heap: a
main.go:8:13: c escapes to heap
main.go:8:13: []interface {} literal does not escape
<autogenerated>:1: .this does not escape
<autogenerated>:1: .this does not escape

```



## 3. 逃逸分析

​		Go 中变量分配在栈还是堆上完全由编译器决定，而原本看起来应该分配在栈上的变量，如果其生命周期获得了延长，被分配在了堆上，就说它发生了逃逸。编译器会自动地去判断变量的生命周期是否获得了延长，整个判断的过程就叫逃逸分析。

```go
package main

func main() {
	a := test()
	println(a)
}

func test() *int {
	b := 2
	return &b
}
```

```bash
$ go tool compile -m main.go
main.go:8:6: can inline test
main.go:3:6: can inline main
main.go:4:11: inlining call to test
main.go:9:2: moved to heap: b
```

​		上面的程序中 b 作为局部变量，如果是在 C 语言中，`return &b` 这样的写法无法通过，因为 b 在函数返回后已经消失了，但在 Go 中，编译器做了一下逃逸分析，发现返回 &b 说明之后 b 还要用，于是就把 b 分配在了堆上。





> 注：调用fmt.Println时变量的生命周期依然得到了扩展，也会造成内存逃逸，但使用println就不会发生内存逃逸。
>
> func main() {
> 	a := 1
> 	fmt.Println(a)
> }



## 总结

如果变量具有地址，就作为堆分配的候选，但如果逃逸分析可以确定其生存周期不会超过函数返回，就会分配在栈上。

> 变量发生逃逸的情况可以总结如下：
>
> 1. **在方法内把局部变量指针返回** 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
> 2. **发送指针或带有指针的值到 channel 中。** 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
> 3. **在一个切片上存储指针或带指针的值。** 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
> 4. **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
> 5. **在 interface 类型上调用方法。** 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。



原文链接：https://shuzang.github.io/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/

